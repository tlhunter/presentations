<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Friends don't let friends Cluster by @tlhunter</title>
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
    <link rel="stylesheet" href="lib/css/hybrid.css">
    <script>
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    </script>
<style>
:root {
  --zeta: #D9D0D0;
  --alpha: #FFFFFF;
  --beta: #8B3F8C;
  --gamma: #A43CA6;
  --delta: #8C4A81;
  --epsilon: #00a8a8;
  --omega: #222222;
  --theta: #00a8a8;
}
body {
  background-color: var(--alpha);
}

.reveal {
  color: var(--epsilon);
}
.reveal pre {
  font-size: 0.7em;
  width: 100%;
  box-shadow: none;
}
.reveal pre .nl {
  color: var(--epsilon);
}
.reveal pre code {
  max-height: 500px;
  padding: 10px 17px;
  border-radius: 10px;
  background-color: var(--omega);
}
.reveal p code,
.reveal h2 code,
.reveal h3 code,
.reveal li code {
  background-color: var(--zeta);
  border-radius: 8px;
  color: var(--beta);
  padding: 2px 10px;
}
.reveal li code,
.reveal p code,
.reveal h2 code,
.reveal h3 code {
  font-size: 0.8em;
}
.reveal li code a {
  color: var(--beta);
}

.reveal h1,
.reveal h2,
.reveal h3,
.reveal h4,
.reveal h5,
.reveal h6 {
  text-transform: initial;
}
.reveal h1,
.reveal h2,
.reveal h3,
.attention {
  color: var(--epsilon);
  text-shadow: 0px 1px 5px var(--zeta);
}
.reveal h3 {
  color: var(--gamma);
}

.reveal section img {
  border: none;
  background: transparent;
  border: 0px;
  box-shadow: none;
}
.reveal blockquote {
  text-align: left;
  width: auto;
  padding: 0.5em 1em;
}
.reveal blockquote .author {
  text-align: right;
}
.reveal a {
  color: var(--omega);
}
.reveal a:hover {
  color: var(--theta);
}
.reveal pre .highlight {
  color: var(--delta);
}

.reveal .progress span {
  background-color: var(--delta);
}
.reveal .controls {
  color: var(--gamma);
}

section.intro img {
  margin-top: 40px;
}

#twitter {
  left: 20px;
}
#website {
  right: 20px;
}
.floater {
  position: absolute;
  bottom: 20px;
  font-size: 3em;
  z-index: 1;
}
.floater, .floater a {
  color: var(--gamma);
  text-decoration: none;
  font-family: "Source Sans Pro", Helvetica, sans-serif;
  font-weight: 600;
  text-shadow: 0px 1px 5px var(--zeta);
}
</style>
  </head>
  <body>
    <div id="twitter" class="floater"><a href="https://twitter.com/tlhunter">@tlhunter</a></div>
    <!-- <div id="website" class="floater"><a href="https://lob.com">lob.com</a></div> -->

    <div class="reveal">
      <div class="slides">

        <section class="intro">
          <br /><!-- judge not -->
          <br />
          <h2>Friends don't let Friends Cluster</h2>
          <h3>Thomas Hunter II</h3>
          <br />
          <p>Content from <em>Distributed Node.js (O'Reilly, ~2021)</em></p>
        </section>


        <section>
          <h2>Roadmap</h2>

          <ol>
            <li><a href="#/chapter-1">What is <code>cluster</code>?</a></li>
            <li><a href="#/chapter-2">What is a Reverse Proxy?</a></li>
            <li><a href="#/chapter-3">Performance comparison</a></li>
          </ol>
        </section>


        <section id="chapter-intro">
          <h3>Problem: One process isn't enough</h3>

          <ul>
            <li>A single process can get overwhelmed</li>
            <li>CPU intensive work blocks event loop</li>
            <li>Perhaps a memory-heavy application</li>
            <li>Non-zero chance that a process will crash</li>
          </ul>
        </section>

        <section>
          <h3>Solution: Run more than one process</h3>

          <ul>
            <li>Also called <em>Horizontal Scaling</em></li>
            <li>In theory, two processes handle twice the load</li>
            <li>If one crashes, the other may survive</li>
          </ul>
        </section>

        <section>
          <h3>What tools are available to<br />run multiple processes?</h3>
        </section>


        <section id="chapter-1">
          <h2>Introducing <code>cluster</code></h2>
        </section>


        <section>
          <h3><code>cluster</code> is a module built into Node.js</h3>

          <pre><code class="javascript">const cluster = require('cluster');</code></pre>

          <img height="400" src="images/cluster-module.png" />
        </section>


        <section>
          <h3><code>cluster</code> makes clustering easy</h3>

<pre><code class="javascript">const cluster = require('cluster');
const http = require('http');
const COOL_VALUE = Math.random();

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);
  cluster.fork(); cluster.fork(); // Assumes 2 CPUs
} else {
  http.createServer((_req, res) =&gt; {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(3001);
  console.log(`Worker ${process.pid} started`);
}</code></pre>
        </section>


        <section>
          <h3>Docs are a little misleading</h3>
          <ul>
            <li>The docs make it <em>look</em> like a single global</li>
            <li>For example, is <code>COOL_VALUE</code> shared?</li>
            <li>Why does the master load the <code>http</code> module?</li>
          </ul>
        </section>


        <section>
          <h3><code>cluster</code>: A clearer example</h3>

<pre><code class="javascript">// master.js
const cluster = require('cluster');
console.log(`Master ${process.pid} is running`);
cluster.setupMaster({exec: __dirname+'/worker.js'});
cluster.fork(); cluster.fork();</code></pre>

<pre><code class="javascript">// worker.js
require('http').createServer((_req, res) =&gt; {
  res.writeHead(200);
  res.end('hello world\n');
}).listen(3001);
console.log(`Worker ${process.pid} started`);</code></pre>
        </section>


        <section>
          <h3>How does <code>cluster</code> work?</h3>
          <ul>
            <li>Each worker tells parent what port to listen</li>
            <li>Master sends messages round robin to workers</li>
            <li>If bind on port <code>0</code>, aka random high, it's consistent</li>
          </ul>

          <pre>node,7500 ./master.js     # pstree command output
  ├─node,7600 server.js
  │   ├─{node},7601
  │   └─{node},7606
  ├─node,7700 server.js
  │   ├─{node},7701
  │   └─{node},7706
  ├─{node},7501
  └─{node},7506
        </section>


        <section>
          <h3>Why is <code>cluster</code> undesirable?</h3>
          <ul>
            <li>You can only route requests on the same machine!
              <ul>
                <li>Sharing RAM and CPU</li>
              </ul>
            </li>
            <li>You're running 3 Node.js instances instead of 2
              <ul>
                <li>In practice, many apps load all modules in master</li>
              </ul>
            </li>
            <li>L4 routing, doesn't route long-lived requests
              <ul>
                <li>L4 means it routes the TCP connection</li>
                <li>Consider the gRPC (over HTTP2) protocol</li>
                <li>The master would stick to a single worker</li>
                <!-- https://gist.github.com/thpham/114d20de8472b2cef966 -->
              </ul>
            </li>
          </ul>
        </section>


        <section id="chapter-2">
          <h2>Introducing the Reverse Proxy</h2>
        </section>


        <section>
          <h3>A Reverse Proxy (like HAProxy) can...</h3>

          <ul>
            <li>Dispatch requests to backend services</li>
            <li>Perform encoding duties (TLS, gzip)</li>
            <li>Clean requests, sticky sessions, modify headers...</li>
            <li>Route to multiple backends based on criteria</li>
          </ul>

          <img height="280" src="images/reverse-proxy.png" />
        </section>


        <section>
          <h3>HAProxy Routing</h3>

          <ul>
            <li>By default routes using round robin (like <code>cluster</code>)</li>
            <li>Configuration is declarative</li>
            <li>HAProxy is extrememly efficient, C, event loop ;)</li>
          </ul>
        </section>


        <section>
          <h3>HAProxy Configuration</h3>

          <ul>
            <li>Basic round robin routing to two backends</li>
          </ul>

          <pre><code class="toml">defaults
  mode http

frontend inbound
  bind localhost:3000
  default_backend web-api

backend web-api
  server web-api-1 localhost:3001
  server web-api-2 localhost:3002</code></pre>
        </section>


        <section>
          <h3>Why prefer HAProxy over <code>cluster</code>?</h3>
          <ul>
            <li>Smaller footprint (tiny C binary)</li>
            <li>Able to route requests between separate machines</li>
            <li>Offload complexity to code you don't maintain!
              <ul>
                <li>More stable than Node.js app code</li>
                <li>Simplifies application (no gzip, TLS, certs)</li>
              </ul>
            </li>
          </ul>
        </section>


        <section id="chapter-3">
          <h2>Performance Comparison</h2>
        </section>

        <section>
          <h3>Testing Approach</h3>

          <ul>
            <li>Each test has HAProxy in front of Node.js</li>
            <li>Either perform gzip/TLS in HAProxy or Node.js</li>
            <li>HAProxy introduces latency via network hop</li>
            <li>Fastify, routing, not basic <code>http</code> module</li>
          </ul>

          <img height="200" src="images/perf-architecture.png" />

          <p><small>Node.js v13.6.0 | HAProxy v2.1.0 | fastify v2.12.0 | fastify-compress v2.0.1 | <code><a href="https://bit.ly/39AgMxS">bit.ly/39AgMxS</a></code></small></p>
        </section>

        <section>
          <h3>HAProxy vs Node.js: TLS Termination</h3>

          <ul>
            <li>17kb payload: HAProxy is ~13% faster</li>
          </ul>

          <img src="images/perf-tls-17.png" height="380" />

          <p><small>Node.js v13.6.0 | HAProxy v2.1.0 | fastify v2.12.0 | fastify-compress v2.0.1 | <code><a href="https://bit.ly/39AgMxS">bit.ly/39AgMxS</a></code></small></p>
        </section>

        <section>
          <h3>HAProxy vs Node.js: TLS Termination</h3>

          <ul>
            <li>170kb payload: HAProxy is ~18% faster</li>
          </ul>

          <img src="images/perf-tls-170.png" height="380" />

          <p><small>Node.js v13.6.0 | HAProxy v2.1.0 | fastify v2.12.0 | fastify-compress v2.0.1 | <code><a href="https://bit.ly/39AgMxS">bit.ly/39AgMxS</a></code></small></p>
        </section>


        <section>
          <h3>HAProxy vs Node.js: gzip Compression</h3>

          <ul>
            <li>17kb payload: HAProxy is ~601% faster</li>
          </ul>

          <img src="images/perf-gzip-17.png" height="380" />

          <p><small>Node.js v13.6.0 | HAProxy v2.1.0 | fastify v2.12.0 | fastify-compress v2.0.1 | <code><a href="https://bit.ly/39AgMxS">bit.ly/39AgMxS</a></code></small></p>
        </section>

        <section>
          <h3>HAProxy vs Node.js: gzip Compression</h3>

          <ul>
            <li>170kb payload: HAProxy is ~407% faster</li>
          </ul>

          <img src="images/perf-gzip-170.png" height="380" />

          <p><small>Node.js v13.6.0 | HAProxy v2.1.0 | fastify v2.12.0 | fastify-compress v2.0.1 | <code><a href="https://bit.ly/39AgMxS">bit.ly/39AgMxS</a></code></small></p>
        </section>


        <section id="final">
          <h3>Fin</h3>

          <ul>
            <li>Follow me: <code><a href="https://twitter.com/tlhunter" title="Twitter @tlhunter">@tlhunter</a></code></li>
            <li>This presentation: <code><a href="http://bit.ly/3bBHuYY" title="Friends don't let friends Cluster">bit.ly/3bBHuYY</a></code></li>
            <li>Benchmark Code: <code><a href="https://bit.ly/39AgMxS">bit.ly/39AgMxS</a></code></li>
            <li>Content from <em>Distributed Node.js (O'Reilly, ~2021)</em></li>
          </ul>
        </section>


      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      Reveal.initialize({
        transition: 'none',
        center: true,
        touch: true,
        controls: false,
        controlsTutorial: false,
        controlsLayout: 'edges',
        controlsBackArrows: 'visible',
        history: true,
        help: false,
        dependencies: [
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
    <script type='text/javascript'>
      var Countly = {
        q: [['track_sessions'], ['track_pageview'], ['track_clicks']],
        app_key: 'eef3b12942f938d7be826186be17930bd522d315',
        url: 'https://analytics.phobosrising.co'
      };
      (function() {
         var cly = document.createElement('script'); cly.type = 'text/javascript';
         cly.async = true; cly.src = '/scripts/countly.min.js';
         cly.onload = function(){Countly.init()};
         var s = document.getElementsByTagName('script')[0];
         s.parentNode.insertBefore(cly, s);
      })();
    </script>
    <noscript><img src='https://analytics.phobosrising.co/pixel.png?app_key=d91922f2a4106e3f1b2851a7bc4852606a289177&begin_session=1'/></noscript>
  </body>
</html>
